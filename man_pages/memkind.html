<!-- Creator     : groff version 1.22.2 -->
<!-- CreationDate: Thu Sep 22 13:05:39 2016 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>MEMKIND</title>

</head>
<body>

<h1 align="center">MEMKIND</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#RETURN VALUE">RETURN VALUE</a><br>
<a href="#KINDS">KINDS</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#FILES">FILES</a><br>
<a href="#ENVIRONMENT">ENVIRONMENT</a><br>
<a href="#SYSTEM CONFIGURATION">SYSTEM CONFIGURATION</a><br>
<a href="#COPYRIGHT">COPYRIGHT</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">memkind &minus;
Heap manager that enables allocations to memory with
different properties. <br>
This header expose EXPERIMENTAL API in except of STANDARD
API placed in section LIBRARY VERSION. API Standards are
described below in this man page.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;memkind.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Link with
-lmemkind</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>ERROR
HANDLING: <br>
void memkind_error_message(int</b> <i>err</i><b>, char</b>
<i>*msg</i><b>, size_t</b> <i>size</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>HEAP
MANAGEMENT: <br>
void *memkind_malloc(memkind_t</b> <i>kind</i><b>,
size_t</b> <i>size</i><b>); <br>
void *memkind_calloc(memkind_t</b> <i>kind</i><b>,
size_t</b> <i>num</i><b>, size_t</b> <i>size</i><b>); <br>
void *memkind_realloc(memkind_t</b> <i>kind</i><b>, void</b>
<i>*ptr</i><b>, size_t</b> <i>size</i><b>); <br>
int memkind_posix_memalign(memkind_t</b> <i>kind</i><b>,
void</b> <i>**memptr</i><b>, size_t</b> <i>alignment</i><b>,
size_t</b> <i>size</i><b>); <br>
void memkind_free(memkind_t</b> <i>kind</i><b>, void</b>
<i>*ptr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>ALLOCATOR
CALLBACK FUNCTION: <br>
void *memkind_partition_mmap(int</b> <i>partition</i><b>,
void</b> <i>*addr</i><b>, size_t</b>
<i>size</i><b>);</b><i>(DEPRECATED)</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>KIND
MANAGMENT: <br>
int memkind_create(const struct memkind_ops</b>
<i>*ops</i><b>, const char</b> <i>*name</i><b>,
memkind_t</b> <i>*kind</i><b>);</b><i>(DEPRECATED)</i>
<b><br>
int memkind_create_pmem(const char</b> <i>*dir</i><b>,
size_t</b> <i>max_size</i><b>, memkind_t</b>
<i>*kind</i><b>); <br>
int memkind_finalize(void);</b><i>(DEPRECATED)</i> <b><br>
int memkind_get_num_kind(int</b>
<i>*num_kind</i><b>);</b><i>(DEPRECATED)</i> <b><br>
int memkind_get_kind_by_partition(int</b>
<i>partition</i><b>, memkind_t</b>
<i>*kind</i><b>);</b><i>(DEPRECATED)</i> <b><br>
int memkind_get_kind_by_name(const char</b> <i>*name</i><b>,
memkind_t</b> <i>*kind</i><b>);</b><i>(DEPRECATED)</i>
<b><br>
int memkind_get_size(memkind_t</b> <i>kind</i><b>,
size_t</b> <i>*total</i><b>, size_t</b>
<i>*free</i><b>);</b><i>(DEPRECATED)</i> <b><br>
int memkind_check_available(memkind_t</b>
<i>kind</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>DECORATORS:
<br>
void memkind_malloc_pre(memkind_t</b> <i>*kind</i><b>,
size_t</b> <i>*size</i><b>); <br>
void memkind_malloc_post(memkind_t</b> <i>kind</i><b>,
size_t</b> <i>size</i><b>, void</b> <i>**result</i><b>);
<br>
void memkind_calloc_pre(memkind_t</b> <i>*kind</i><b>,
size_t</b> <i>*nmemb</i><b>, size_t</b> <i>*size</i><b>);
<br>
void memkind_calloc_post(memkind_t</b> <i>kind</i><b>,
size_t</b> <i>nmemb</i><b>, size_t</b> <i>size</i><b>,
void</b> <i>**result</i><b>); <br>
void memkind_posix_memalign_pre(memkind_t</b>
<i>*kind</i><b>, void</b> <i>**memptr</i><b>, size_t</b>
<i>*alignment</i><b>, size_t</b> <i>*size</i><b>); <br>
void memkind_posix_memalign_post(memkind_t</b>
<i>kind</i><b>, void</b> <i>**memptr</i><b>, size_t</b>
<i>alignment</i><b>, size_t</b> <i>size</i><b>, int</b>
<i>*err</i><b>); <br>
void memkind_realloc_pre(memkind_t</b> <i>*kind</i><b>,
void</b> <i>**ptr</i><b>, size_t</b> <i>*size</i><b>); <br>
void memkind_realloc_post(memkind_t</b> <i>kind</i><b>,
void</b> <i>*ptr</i><b>, size_t</b> <i>size</i><b>, void</b>
<i>**result</i><b>); <br>
void memkind_free_pre(memkind_t</b> <i>*kind</i><b>,
void</b> <i>**ptr</i><b>); <br>
void memkind_free_post(memkind_t</b> <i>kind</i><b>,
void</b> <i>*ptr</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>LIBRARY
VERSION: <br>
int memkind_get_version();</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>memkind_error_message</b>()
converts an error number <i>err</i> returned by a member of
the memkind interface to an error message <i>msg</i> where
the maximium size of the message is passed by the
<i>size</i> parameter.</p>

<p style="margin-left:11%; margin-top: 1em"><b>HEAP
MANAGMENT:</b> <br>
The functions described in this section define a heap
manager with an interface modeled on the ISO C standard
API&rsquo;s, except that the user must specify the
<i>kind</i> of memory with the first argument to each
function. See the <b>KINDS</b> section below for a full
description of the implemented kinds.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_malloc</b>()
allocates <i>size</i> bytes of uninitialized memory of the
specified <i>kind</i>. The allocated space is suitably
aligned (after possible pointer coercion) for storage of any
type of object. If <i>size</i> is 0, then
<b>memkind_malloc</b>() returns NULL.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_calloc</b>()
allocates space for <i>num</i> objects each <i>size</i>
bytes in length in memory of the specified <i>kind</i>. The
result is identical to calling <b>memkind_malloc</b>() with
an argument of <i>num</i>*<i>size</i>, with the exception
that the allocated memory is explicitly initialized to zero
bytes. If <i>num</i> or <i>size</i> is 0, then
<b>memkind_calloc</b>() returns NULL.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_realloc</b>()
changes the size of the previously allocated memory
referenced by <i>ptr</i> to <i>size</i> bytes of the
specified <i>kind</i>. The contents of the memory are
unchanged up to the lesser of the new and old sizes. If the
new size is larger, the contents of the newly allocated
portion of the memory are undefined. Upon success, the
memory referenced by <i>ptr</i> is freed and a pointer to
the newly allocated high bandwidth memory is returned.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:
memkind_realloc</b>() may move the memory allocation,
resulting in a different return value than <i>ptr</i>.</p>

<p style="margin-left:11%; margin-top: 1em">If <i>ptr</i>
is NULL, the <b>memkind_realloc</b>() function behaves
identically to <b>memkind_malloc</b>() for the specified
size. The address <i>ptr</i>, if not NULL, must have been
returned by a previous call to <b>memkind_malloc</b>(),
<b>memkind_calloc</b>(), <b>memkind_realloc</b>(), or
<b>memkind_posix_memalign</b>() with the same <i>kind</i> as
specified to the call to <b>memkind_realloc</b>().
Otherwise, if <i>memkind_free(kind, ptr)</i> was called
before, undefined behavior occurs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_posix_memalign</b>()
allocates <i>size</i> bytes of memory of a specified
<i>kind</i> such that the allocation&rsquo;s base address is
an even multiple of <i>alignment</i>, and returns the
allocation in the value pointed to by <i>memptr</i>. The
requested <i>alignment</i> must be a power of 2 at least as
large as <i>sizeof(void *)</i>. If <i>size</i> is 0, then
<b>memkind_posix_memalign</b>() returns NULL.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_free</b>()
causes the allocated memory referenced by <i>ptr</i> to be
made available for future allocations. This pointer must
have been returned by a previous call to
<b>memkind_malloc</b>(), <b>memkind_calloc</b>(),
<b>memkind_realloc</b>(), or
<b>memkind_posix_memalign</b>(). Otherwise, if
<i>memkind_free(kind, ptr)</i> was already called before,
undefined behavior occurs. If <i>ptr</i> is NULL, no
operation is performed. The value of <b>MEMKIND_DEFAULT</b>
can be given as the <i>kind</i> for all buffers allocated by
a kind that leverages the jemalloc allocator. This includes
all interally defined kinds other than those that use
gigabyte pages. In cases where the kind is unknown in the
context of the call to <b>memkind_free</b>() <b>0</b> can be
given as the <i>kind</i> specified to <b>memkind_free</b>()
but this will require a look up that can be bypassed by
specifying a non-zero value.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ALLOCATOR
CALLBACK FUNCTION:</b> <br>
This section describes the memkind interface which is used
internally by the heap manager. For this API the kind is
determined by the partition index. This enables the
underlying heap manager to call routines with standard type
arguments, and allows the heap manager implementation to be
independent of the specifics of the <i>memkind_t</i>
implementation. Currently there is only one callback
function.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_partition_mmap</b>()
which is a wrapper around the <b>mmap</b>(2) system call.
The hint address <i>addr</i> and the length in bytes of the
buffer to be allocated <i>size</i> are passed through to
<b>mmap</b>(2). The other <b>mmap</b>(2) parameters are
determined by the kind operations.</p>

<p style="margin-left:11%; margin-top: 1em"><b>KIND
MANAGEMENT:</b> <br>
There are built-in kinds that are always available, and
these are enumerated in the <b>KINDS</b> section. The user
can also create their own kinds of memory. This section
describes the API&rsquo;s that enable the tracking of the
different kinds of memory and determining their
properties.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_create</b>()<b>(DEPRECATED)</b>
is used to create a new kind of memory. It takes as input a
pointer to a vtable called <i>ops</i> that determines the
operations that define the kind of memory. These operations
can be taken from one of the memkind built-in
implementations defined in the memkind headers, or it can be
user implemented. The requirements for each operation is
defined in the <b>MEMKIND OPERATIONS</b> section. See the
<b>SEE ALSO</b> section for the list of memkind header files
that implement the built-in operations: each header has a
man page.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_create_pmem</b>()
is a convenience function used to create a file-backed kind
of memory. It allocates a temporary file in the given
directory <i>dir</i>. The file is created in a fashion
similar to <b>tmpfile</b>(3), so that the file name does not
appear when the directory is listed and the space is
automatically freed when the program terminates. The file is
truncated to a size of <i>max_size</i> bytes and the
resulting space is memory-mapped. Then, the actual pmem
<i>kind</i> is created by calling <b>memkind_create</b>()
with a unique <i>name</i> string (&quot;pmemXXXXXXXX&quot;),
and the pointer to <b>MEMKIND_PMEM_OPS</b> as <i>ops</i>
argument. <br>
Note that the actual file system space is not allocated
immediately, but only on a call to
<b>memkind_pmem_mmap</b>() (see <b>memkind_pmem</b>(3)).
This allows to create a pmem memkind of a pretty large size
without the need to reserve in advance the corresponding
file system space for the entire heap. The minimum
<i>max_size</i> value allowed by the library is defined in
<b>&lt;memkind_pmem.h&gt;</b> as
<b>MEMKIND_PMEM_MIN_SIZE</b>. Calling
<b>memkind_create_pmem</b>() with a size smaller than that
will return an error. The maximum allowed size is not
limited by <b>memkind</b>, but by the file system specified
by the <i>dir</i> argument. The <i>max_size</i> passed in is
the raw size of the memory pool and <b>jemalloc</b> will use
some of that space for its own metadata.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_finalize</b>()
releases all resources associated with the memkind library
including the resouces used by all of the kinds that were
created, but it does not free memory allocated with the
<b>HEAP MANAGEMENT</b> interface. This must be the last call
to the memkind library before application termination, but
it can be called more than once.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_get_num_kind</b>()
sets <i>num_kind</i> to the number of available kinds of
memory. This accounts for the built-in static kinds and any
dynamically created kinds. Since there is a one-to-one
mapping between partitions and kinds, this is also the
number of partitions.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_get_kind_by_partition</b>()
sets <i>kind</i> to the memory kind associated with the
<i>partition</i> index which must be in the range [0,
<i>num_kind</i> - 1] where num_kind can be retrieved with
the <b>memkind_get_num_kind</b>() function.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_get_kind_by_name</b>()
sets <i>kind</i> to the memory kind associated with the
<i>name</i> string specified. All of the built-in kinds have
name strings that are the lower-case version of name given
in the <b>KINDS</b> section (for example: MEMKIND_DEFAULT
has <i>name</i> &quot;memkind_default&quot;)</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_get_size</b>()<b>(DEPRECATED)</b>
sets <i>total</i> to the number of bytes on the system which
can be allocated with the specified <i>kind</i>, and sets
<i>free</i> to the number of unallocated bytes available of
memory with the specified <i>kind.</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:</b>
These numbers may be specific to the CPU of the calling
thread if the <i>kind</i> binds memory to NUMA nodes
associated with the CPU.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memkind_check_available</b>()
Returns a zero if the specified <i>kind</i> is available or
an error code from the <b>ERRORS</b> section if it is
not.</p>


<p style="margin-left:11%; margin-top: 1em"><b>DECORATORS:</b>
<br>
The memkind library enables the user to define decorator
functions that can be called before and after each memkind
heap management API. The decorators that are called at the
beginning of the function end are named after that function
with <i>_pre</i> appended to the name, and those that are
called at the end of the function are named after that
function with <i>_post</i> appended to the name. These are
weak symbols, and if they are not present at link time they
are not called. The memkind library does not define these
symbols which are reserved for user definition. These
decorators can be used to track calls to the heap management
interface or to modify parameters. The decorators that are
called at the beginning of the allocator pass all inputs by
reference, and the decorators that are called at the end of
the allocator pass the output by reference. This enables the
modification of the input and output of each heap management
function by the decorators.</p>

<p style="margin-left:11%; margin-top: 1em"><b>LIBRARY
VERSION</b> <br>
The memkind library version scheme consist major, minor and
patch numbers separated by dot. Combining those numbers, we
got the following representation: <br>
major.minor.patch, where:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>-major number is incremented whenever API is changed
(loss of backward compatibility),</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>-minor number is incremented whenever additional
extensions are introduced, or behavior has been changed,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>-patch number is incremented whenever small bug fixes
are added.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">memkind library
provide numeric representation of the version by exposing
the following API: <br>
int memkind_get_version() return version number represented
by a single integer number, obtained from the formula: <br>
major * 1000000 + minor * 1000 + patch</p>

<p style="margin-left:11%; margin-top: 1em">Note: major
&lt; 1 means unstable API.</p>

<p style="margin-left:11%; margin-top: 1em">API standards:
<br>
-STANDARD API, API is considered as stable <br>
-NON-STANDARD API, API is considered as stable, however this
is not a standard way to use memkind <br>
-EXPERIMENTAL API, API is considered as unstable and the
subject to change</p>

<p style="margin-left:11%; margin-top: 1em"><b>MEMKIND
OPERATIONS:</b> <br>
The <i>memkind_ops</i> structure is a vtable that defines
the operations which determine the kind of memory. This
design pattern is modeled after the &quot;mix-in&quot;
pattern used in the Linux kernel to enable some of the
features of an object oriented language in C. This section
defines the inputs, outputs and responsiblities of each
function pointer enumerated in the <i>memkind_ops</i>
structure. Each of these methods takes a <b>memkind_t</b>
argument as its first parameter which shall be self
referencing. In this documentation the function pointers in
the <i>memkind_ops</i> structure will be prepended with
&quot;<b>ops.</b>&quot; and should be considered the
operation associated with the <i>kind</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
ops.create(memkind_t</b> <i>kind</i><b>, const struct
memkind_ops</b> <i>*ops</i><b>, const char</b>
<i>*name</i><b>);</b> <br>
shall instantiate all of the dynamic resources associated
with the <i>kind</i>. It takes a pointer to the vtable
structure <i>ops</i> which has a function pointer for each
of methods defined in this section of the man page. If any
methods are unnessary to the implementation of the
<i>kind</i> these function pointers shall be set to
<b>NULL</b>. The <i>name</i> string is an input parameter
that identifies the kind of memory so that it can be fetched
with the <b>memkind_get_kind_by_name</b>() function.
Typically this method is either a pointer to the function
<b>memkind_default_create</b>() defined in
<i>&lt;memkind_default.h&gt;</i>, or a function that calls
<b>memkind_default_create</b>() before performing other
setup.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
ops.destroy(memkind_t</b> <i>kind</i><b>);</b> <br>
shall free all of the dynamic resources reserved by the
<b>ops.create</b>() method. If no dynamic resources were
explicitly allocated in the <i>ops.create</i>() method, this
pointer can be set to <b>NULL</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
*ops.malloc(memkind_t</b> <i>kind</i><b>, size_t</b>
<i>size</i><b>);</b> <br>
shall implement <b>memkind_malloc</b>(), as described
above.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
*ops.calloc(memkind_t</b> <i>kind</i><b>, size_t</b>
<i>num</i><b>, size_t</b> <i>size</i><b>);</b> <br>
shall implement <b>memkind_calloc</b>(), as described
above.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
ops.posix_memalign(memkind_t</b> <i>kind</i><b>, void</b>
<i>**memptr</i><b>, size_t</b> <i>alignment</i><b>,
size_t</b> <i>size</i><b>);</b> <br>
shall implement <b>memkind_posix_memalign</b>(), as
described above.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
*ops.realloc(memkind_t</b> <i>kind</i><b>, void</b>
<i>*ptr</i><b>, size_t</b> <i>size</i><b>);</b> <br>
shall implement <b>memkind_realloc</b>(), as described
above.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
ops.free(memkind_t</b> <i>kind</i><b>, void</b>
<i>*ptr</i><b>);</b> <br>
shall implement <b>memkind_free</b>(), as described
above.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
*ops.mmap(memkind_t</b> <i>kind</i><b>, void</b>
<i>*addr</i><b>, size_t</b> <i>size</i><b>);</b> shall wrap
the <b>mmap</b>(2) <b>mbind</b>(2) and <b>madvise</b>(2)
system calls while passing <i>addr</i> and <i>size</i>
through and determining all other parameters for
<b>mmap</b>(2) <b>mbind</b>(2) and <b>madvise</b>(2) by
calling other functions resolved by the <b>kind.ops</b>
vtable. This function shall return a virtual address to the
memory mapped, or <b>MAP_FAILED</b> as defined in
<i>&lt;sys/mman.h&gt;</i> which is <i>(void *) -1</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
ops.mbind(memkind_t</b> <i>kind</i><b>, void</b>
<i>*ptr</i><b>, size_t</b> <i>size</i><b>);</b> <br>
shall wrap the <b>mbind</b>(2) system call and pass through
the start address <i>ptr</i> to be bound, and the number of
bytes <i>size</i> from that address to be bound. The other
parmeters to <b>mbind</b>(2) shall be determined by calling
other functions resolved by the <b>kind.ops</b> vtable.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
ops.madvise(memkind_t</b> <i>kind</i><b>, void</b>
<i>*addr</i><b>, size_t</b> <i>size</i><b>);</b> <br>
shall wrap the <b>madvise</b>(2) system call and pass
through the start address <i>addr</i> to be advised, and the
number of bytes <i>size</i> from that address to be advised.
This may call <b>madvise</b>(2) multiple times with
different advice.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
ops.get_mmap_flags(memkind_t</b> <i>kind</i><b>, int</b>
<i>*flags</i><b>);</b> <br>
shall set <i>flags</i> to a value appropriate for passing to
the <i>mmap</i>(2) system call for the <i>kind</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
ops.get_mbind_mode(memkind_t</b> <i>kind</i><b>, int</b>
<i>*mode</i><b>);</b> <br>
shall set <i>mode</i> to a value appropriate for passing to
the <i>mmap</i>(2) system call for the <i>kind</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
ops.get_mbind_nodemask(memkind_t</b> <i>kind</i><b>,
unsigned long</b> <i>*nodemask</i><b>, unsigned long</b>
<i>maxnode</i><b>);</b> <br>
shall set the <i>nodemask</i> of length <i>maxnode</i> bits
to a value appropriate for passing to the <i>mbind</i>(2)
system call for the <i>kind</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
ops.get_arena(memkind_t</b> <i>kind</i><b>, unsigned int</b>
<i>*arena</i><b>,&quot;</b> <i>size_t</i>
<b>size</b><i>);</i> <br>
shall set <i>arena</i> to an index appropriate for the
<i>kind,</i> allocation <i>size,</i> and CPU when using the
jemalloc arena allocation through the <b>jemk_mallocx</b>()
API. Size parameter is not used at the moment, but will be
necesary for integration with jemalloc 4.0.x (planned for
one of the future releases).</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
ops.get_size(memkind_t</b> <i>kind</i><b>, size_t</b>
<i>*total</i><b>, size_t</b> <i>*free</i><b>);</b> <br>
shall implement <b>memkind_get_size</b>(), as described
above.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
ops.check_available(memkind_t</b> <i>kind</i><b>);</b> <br>
shall return 0 if the <i>kind</i> is available on the
system, and an error code if not.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
ops.check_addr(memkind_t</b> <i>kind</i><b>, void</b>
<i>*addr</i><b>);</b> <br>
shall return 0 if the <i>addr</i> can be freed with the
specified <i>kind</i> and an error code otherwise. If the
memory cannot be freed with <b>jemk_free</b>(), then at
least one of the instantiated kinds must return 0 to enable
freeing.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
ops.init_once(void);</b> <br>
this function pointer shall be set to NULL for any kind that
is not built-in. The method is used to allocate dynamic
resources for built-in kinds without requiring and
initialization routine.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>memkind_calloc</b>(),
<b>memkind_malloc</b>(), and <b>memkind_realloc</b>(),
return the pointer to the allocated memory, or NULL if the
request fails. <b>memkind_free</b>() and
<b>memkind_error_message</b>() do not have return values.
All other memkind API&rsquo;s return 0 upon success, and an
error code defined in the ERRORS section upon failure. The
memkind library avoids setting <i>errno</i> directly, but
calls to underlying libraries and system calls may set
<i>errno</i>.</p>

<h2>KINDS
<a name="KINDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The available
kinds of memory <b><br>
MEMKIND_DEFAULT</b></p>

<p style="margin-left:22%;">Default allocation using
standard memory and default page size.</p>

<p style="margin-left:11%;"><b>MEMKIND_HUGETLB</b></p>

<p style="margin-left:22%;">Allocate from standard memory
using huge pages. Note: This kind requires huge pages
configuration described in SYSTEM CONFIGURATION section.</p>

<p style="margin-left:11%;"><b>MEMKIND_GBTLB</b></p>

<p style="margin-left:22%;">Allocate from standard memory
using giga byte huge pages. Note: This kind requires
gigabyte pages configuration described in SYSTEM
CONFIGURATION section.</p>

<p style="margin-left:11%;"><b>MEMKIND_INTERLEAVE</b></p>

<p style="margin-left:22%;">Allocate pages interleaved
across all NUMA nodes with transparent huge pages
disabled.</p>

<p style="margin-left:11%;"><b>MEMKIND_HBW</b></p>

<p style="margin-left:22%;">Allocate from the closest high
bandwidth memory NUMA node at time of allocation. If there
is not enough high bandwidth memory to satisfy the request
<i>errno</i> is set to ENOMEM and the allocated poitner is
set to NULL.</p>

<p style="margin-left:11%;"><b>MEMKIND_HBW_HUGETLB</b></p>

<p style="margin-left:22%;">Same as <b>MEMKIND_HBW</b>
except the allocation is backed by huge pages. Note: This
kind requires huge pages configuration described in SYSTEM
CONFIGURATION section.</p>


<p style="margin-left:11%;"><b>MEMKIND_HBW_PREFERRED</b></p>

<p style="margin-left:22%;">Same as <b>MEMKIND_HBW</b>
except that if there is not enough high bandwidth memory to
satisfy the request, the allocation will fall back on
standard memory.</p>


<p style="margin-left:11%;"><b>MEMKIND_HBW_PREFERRED_HUGETLB</b></p>

<p style="margin-left:22%;">Same as
<b>MEMKIND_HBW_PREFERRED</b> except the allocation is backed
by huge pages. Note: This kind requires huge pages
configuration described in SYSTEM CONFIGURATION section.</p>

<p style="margin-left:11%;"><b>MEMKIND_HBW_GBTLB</b></p>

<p style="margin-left:22%;">Same as <b>MEMKIND_HBW</b>
except the allocation is backed by one gigabyte huge pages.
Note that <i>size</i> can take on any value, but full
gigabyte pages will allocated for each request, so remainder
of the last page will be wasted. A good use case scenario is
to grow a buffer in the course of an application with
reallocs. In this case, if there is enough memory available
within in already allocated gigabyte page, newer pages are
not fetched. This is demonstrated in the examples directory
with gb_realloc_example.c This kind requires gigabyte pages
configuration described in SYSTEM CONFIGURATION section.</p>


<p style="margin-left:11%;"><b>MEMKIND_HBW_PREFERRED_GBTLB</b></p>

<p style="margin-left:22%;">Same as
<b>MEMKIND_HBW_GBTLB</b> except that if there is not enough
high bandwidth memory to satisfy the request, the allocation
will fall back on standard memory. Note: This kind requires
gigabyte pages configuration described in SYSTEM
CONFIGURATION section.</p>


<p style="margin-left:11%;"><b>MEMKIND_HBW_INTERLEAVE</b></p>

<p style="margin-left:22%;">Same as <b>MEMKIND_HBW</b>
except that the pages that support the allocation are
interleaved across all high bandwidth nodes and transparent
huge pages are disabled.</p>

<p style="margin-left:11%;"><b>MEMKIND_PMEM</b></p>

<p style="margin-left:22%;">Allocate from file-backed heap.
If the amount of allocated memory exceeds the total size of
memory-mapped file associated with given kind, or if the
actual file system space cannot be allocated <i>errno</i> is
set to ENOMEM and the allocated poitner is set to NULL.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>memkind_posix_memalign</b>()</p>

<p style="margin-left:22%;">returns the one of the POSIX
standard error codes <b>EINVAL</b> or <b>ENOMEM</b> as
defined in <i>&lt;errno.h&gt;</i> if an error occurs (these
have positive values). If the <i>alignment</i> parameter is
not a power of two, or is not a multiple of <i>sizoeof(void
*)</i>, then <b>EINVAL</b> is returned. If there is
insufficient memory to satisfy the request then
<b>ENOMEM</b> is returned.</p>

<p style="margin-left:11%; margin-top: 1em">All functions
other than <b>memkind_posix_memalign</b>() which have an
integer return type return one of the negative error codes
as defined in <i>&lt;memkind.h&gt;</i> and described below.
<b><br>
MEMKIND_ERROR_UNAVAILABLE</b></p>

<p style="margin-left:22%;">Requested memory kind is not
available</p>

<p style="margin-left:11%;"><b>MEMKIND_ERROR_MBIND</b></p>

<p style="margin-left:22%;">Call to <b>mbind</b>(2)
failed</p>

<p style="margin-left:11%;"><b>MEMKIND_ERROR_MMAP</b></p>

<p style="margin-left:22%;">Call to <b>mmap</b>(2)
failed</p>

<p style="margin-left:11%;"><b>MEMKIND_ERROR_MEMALIGN
(DEPRECATED)</b></p>

<p style="margin-left:22%;">Call to
<b>jemk_posix_memalign</b>() failed</p>

<p style="margin-left:11%;"><b>MEMKIND_ERROR_MALLCTL
(DEPRECATED)</b></p>

<p style="margin-left:22%;">Call to <b>jemk_mallctl</b>()
failed</p>


<p style="margin-left:11%;"><b>MEMKIND_ERROR_MALLOC</b></p>

<p style="margin-left:22%;">Call to <b>jemk_malloc</b>()
failed</p>

<p style="margin-left:11%;"><b>MEMKIND_ERROR_GETCPU
(DEPRECATED)</b></p>

<p style="margin-left:22%;">Call to <b>sched_getcpu</b>()
returned out of range</p>

<p style="margin-left:11%;"><b>MEMKIND_ERROR_TIEDISTANCE
(DEPRECATED)</b></p>

<p style="margin-left:22%;">Two NUMA memory nodes are
equidistant from target cpu node</p>

<p style="margin-left:11%;"><b>MEMKIND_ERROR_ALIGNMENT
(DEPRECATED)</b></p>

<p style="margin-left:22%;">Alignment must be a power of
two and larger than sizeof(void *)</p>


<p style="margin-left:11%;"><b>MEMKIND_ERROR_ALLOCM</b></p>

<p style="margin-left:22%;">Call to <b>jemk_allocm</b>()
failed</p>


<p style="margin-left:11%;"><b>MEMKIND_ERROR_ENVIRON</b></p>

<p style="margin-left:22%;">Error parsing environment
variable (MEMKIND_*)</p>


<p style="margin-left:11%;"><b>MEMKIND_ERROR_INVALID</b></p>

<p style="margin-left:22%;">Invalid input arguments to
memkind routine</p>

<h2>FILES
<a name="FILES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>/usr/bin/memkind-hbw-nodes</i></p>

<p style="margin-left:22%;">Prints a comma separated list
of high bandwidth nodes.</p>

<h2>ENVIRONMENT
<a name="ENVIRONMENT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>MEMKIND_HBW_NODES</b></p>

<p style="margin-left:22%;">This environment variable is a
comma separated list of NUMA nodes that are treated as high
bandwidth. Uses the <i>libnuma</i> routine
<b>numa_parse_nodestring</b>() for parsing, so the syntax
described in the <b>numa</b>(3) man page for this routine
applies: e.g 1-3,5 is a valid setting.</p>


<p style="margin-left:11%;"><b>MEMKIND_ARENA_NUM_PER_KIND</b></p>

<p style="margin-left:22%;">This environment variable
allows leveraging internal mechanism of the library for
setting number of arenas per kind. Value should be a
positive integer (not greater than INT_MAX defined in
limits.h). The user should set the value based on the
characteristics of application that is using the library.
Higher value can provide better performance in extremely
multithreaded applications at the cost of memory overhead.
See section &quot;IMPLEMENTATION NOTES&quot; of
<b>jemalloc</b>(3) for more details about arenas.</p>

<p style="margin-left:11%;"><b>MEMKIND_DEBUG</b></p>

<p style="margin-left:22%;">Controls tracing mechanism in
memkind. Setting <b>MEMKIND_DEBUG</b> to &quot;1&quot;
enables printing messages like errors and general
informations about environment to <i>stderr.</i></p>

<h2>SYSTEM CONFIGURATION
<a name="SYSTEM CONFIGURATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Interfaces for
obtaining 2MB and 1GB pages (HUGETLB and GBTLB) need
allocated huge pages in the kernel&rsquo;s huge page pool.
<b><br>
HUGETLB (huge pages)</b></p>

<p style="margin-left:22%;">Current number of
&quot;persistent&quot; huge pages can be read from
/proc/sys/vm/nr_hugepages file. Proposed way of setting
hugepages is: &quot;sudo sysctl
vm.nr_hugepages=&lt;number_of_hugepages&gt;&quot;. More
informations can be found here:
https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt</p>

<p style="margin-left:11%;"><b>GBTLB (gigabyte
pages)</b></p>

<p style="margin-left:22%;">Number of preallocated gigabyte
pages can be read from /proc/cmdline (hugepagesz=1G
nr_hugepages=N). Setting gigabyte hugepages is available by
kernel commandline. From 3.16 and later kernels, users can
allocate gigabyte pages like its done for 2MB pages.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (C)
2014 - 2016 Intel Corporation. All rights reserved.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>malloc</b>(3),
<b>numa</b>(3), <b>numactl</b>(8), <b>mbind</b>(2),
<b>mmap</b>(2), <b>move_pages</b>(2), <b>jemalloc</b>(3),
<b>memkind_default</b>(3), <b>memkind_arena</b>(3),
<b>memkind_hbw</b>(3), <b>memkind_hugetlb</b>(3),
<b>memkind_gbtlb</b>(3), <b>memkind_pmem</b>(3)</p>
<hr>
</body>
</html>
